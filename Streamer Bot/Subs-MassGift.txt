using System;
using System.IO;
using System.Collections;
using System.Collections.Generic;
using System.Globalization;
using System.Threading;

public class CPHInline
{
    private static string ResolveDisplayNameFromArgs(Dictionary<string, object> args)
    {
        if (args != null)
        {
            if (args.ContainsKey("userName") && args["userName"] != null)
            {
                string v = args["userName"].ToString().Trim();
                if (!string.IsNullOrEmpty(v)) return v;
            }

            if (args.ContainsKey("displayName") && args["displayName"] != null)
            {
                string v = args["displayName"].ToString().Trim();
                if (!string.IsNullOrEmpty(v)) return v;
            }

            if (args.ContainsKey("user") && args["user"] != null)
            {
                string v = args["user"].ToString().Trim();
                if (!string.IsNullOrEmpty(v)) return v;
            }
        }

        return "Someone";
    }

    private static string JsEscape(string input)
    {
        if (string.IsNullOrEmpty(input)) return "";
        return input
            .Replace("\\", "\\\\")
            .Replace("\"", "\\\"")
            .Replace("\r", " ")
            .Replace("\n", " ");
    }

    private static bool TryParsePositiveWhole(object raw, out int parsed)
    {
        parsed = 0;
        if (raw == null) return false;
        string s = raw.ToString()?.Trim() ?? "";
        if (string.IsNullOrEmpty(s)) return false;

        if (int.TryParse(s, out int direct) && direct > 0)
        {
            parsed = direct;
            return true;
        }

        if (double.TryParse(s, NumberStyles.Any, CultureInfo.InvariantCulture, out double dec))
        {
            int rounded = (int)Math.Round(dec, MidpointRounding.AwayFromZero);
            if (rounded > 0)
            {
                parsed = rounded;
                return true;
            }
        }

        return false;
    }

    private static int TryCountRecipients(Dictionary<string, object> args, out string trace)
    {
        trace = "recipients=none";
        if (!args.ContainsKey("recipients") || args["recipients"] == null) return 0;

        try
        {
            // Handles list-like objects; skip string which is IEnumerable<char>.
            if (args["recipients"] is IEnumerable seq && !(args["recipients"] is string))
            {
                int count = 0;
                foreach (var _ in seq) count++;
                trace = "recipients.count=" + count;
                return count > 0 ? count : 0;
            }
        }
        catch (Exception ex)
        {
            trace = "recipients.error=" + ex.Message;
        }

        return 0;
    }

    private static int TryCountIndexedRecipients(Dictionary<string, object> args, out string trace)
    {
        var indexes = new List<int>();
        const string prefix = "recipient.";

        foreach (var key in args.Keys)
        {
            if (string.IsNullOrEmpty(key) || !key.StartsWith(prefix, StringComparison.OrdinalIgnoreCase))
                continue;

            int start = prefix.Length;
            int dot = key.IndexOf('.', start);
            if (dot <= start) continue;

            string indexPart = key.Substring(start, dot - start);
            if (int.TryParse(indexPart, out int idx) && idx >= 0 && !indexes.Contains(idx))
                indexes.Add(idx);
        }

        int count = indexes.Count;
        trace = "indexedRecipients.count=" + count;
        return count;
    }

    private static int ResolveMassAddAmount(Dictionary<string, object> args, out string selectedKey, out string trace)
    {
        // Kick mass gift variable first, then common fallbacks.
        string[] keys = new[]
        {
            "subBombCount",
            "sub_gift_count", "gift_amount", "amount", "qty", "count",
            "subscription.count", "gifts.count", "gift_count", "gifted_count",
            "subscriptions", "subs", "sub_count", "total_gifts"
        };

        var parts = new List<string>();
        selectedKey = "fallback";

        foreach (var key in keys)
        {
            if (!args.ContainsKey(key) || args[key] == null) continue;
            object raw = args[key];
            if (TryParsePositiveWhole(raw, out int parsed))
            {
                selectedKey = key;
                parts.Add(key + "=" + raw + " -> " + parsed);
                trace = string.Join(" | ", parts);
                return parsed;
            }
            parts.Add(key + "=" + raw + " -> invalid");
        }

        int recipientsCount = TryCountRecipients(args, out string recipientsTrace);
        parts.Add(recipientsTrace);
        if (recipientsCount > 0)
        {
            selectedKey = "recipients";
            trace = string.Join(" | ", parts);
            return recipientsCount;
        }

        int indexedRecipientsCount = TryCountIndexedRecipients(args, out string indexedRecipientsTrace);
        parts.Add(indexedRecipientsTrace);
        if (indexedRecipientsCount > 0)
        {
            selectedKey = "indexed_recipients";
            trace = string.Join(" | ", parts);
            return indexedRecipientsCount;
        }

        selectedKey = "fallback";
        parts.Add("fallback -> 1");
        trace = string.Join(" | ", parts);
        return 1;
    }

    private static int RecoverCountFromFollowersFile(string fullPath)
    {
        if (!File.Exists(fullPath)) return 0;
        try
        {
            string content = File.ReadAllText(fullPath);
            string[] parts = content.Split('"');
            if (parts.Length > 1 && int.TryParse(parts[1], out int parsed) && parsed >= 0)
                return parsed;
        }
        catch { }
        return 0;
    }

    public bool Execute()
    {
        string folderPath = CPH.GetGlobalVar<string>("overlayPath");
        if (string.IsNullOrEmpty(folderPath))
        {
            CPH.LogWarn("[SUB MASS] overlayPath global variable is not set.");
            return false;
        }

        string fullPath = Path.Combine(folderPath, "Data", "data_followers.js");
        string triggerName = args.ContainsKey("triggerName") ? args["triggerName"].ToString() : "";
        if (!string.IsNullOrEmpty(triggerName) && triggerName.IndexOf("Gift", StringComparison.OrdinalIgnoreCase) < 0)
        {
            CPH.LogInfo($"[SUB MASS] Ignored trigger '{triggerName}' (non-gift).");
            return true;
        }
        string triggerId = args.ContainsKey("triggerId") ? args["triggerId"].ToString() : "manual";
        string uniqueId = triggerId + "_" + DateTime.Now.Ticks;

        string gifter = ResolveDisplayNameFromArgs(args);
        string recipientUser = args.ContainsKey("recipientUser") ? args["recipientUser"].ToString() :
            (args.ContainsKey("recipient.userName") ? args["recipient.userName"].ToString() : "");
        string displayUser = gifter;

        int addAmount = ResolveMassAddAmount(args, out string selectedKey, out string parseTrace);
        string argKeys = args != null ? string.Join(", ", args.Keys) : "(none)";
        CPH.LogInfo($"[SUB MASS] Trigger={triggerName} Gifter={gifter} Recipient={recipientUser} AddAmount={addAmount} Key={selectedKey} Args=[{argKeys}] Parse=[{parseTrace}]");

        using (var mutex = new Mutex(false, @"Global\BulletPunjabi_SubCounter"))
        {
            bool lockTaken = false;
            try
            {
                lockTaken = mutex.WaitOne(TimeSpan.FromSeconds(5));
                if (!lockTaken)
                {
                    CPH.LogWarn("[SUB MASS] Could not acquire counter lock in 5s.");
                    return false;
                }

                int fileCount = RecoverCountFromFollowersFile(fullPath);
                int memoryCount = 0;
                object stored = CPH.GetGlobalVar<int>("dailyFollowersCount", true);
                if (stored != null) memoryCount = (int)stored;

                int baseline = fileCount;
                if (baseline <= 0 && memoryCount > 0) baseline = memoryCount;
                if (fileCount != memoryCount)
                    CPH.LogInfo($"[SUB MASS] Baseline mismatch file={fileCount} memory={memoryCount} used={baseline}");

                int currentCount = baseline + Math.Max(1, addAmount);
                CPH.SetGlobalVar("dailyFollowersCount", currentCount, true);

                string content = "window.updateFollowers(\"" + currentCount + "\", \"Latest: " + JsEscape(displayUser) + "\", \"" + JsEscape(uniqueId) + "\");";
                Directory.CreateDirectory(Path.GetDirectoryName(fullPath));
                File.WriteAllText(fullPath, content);

                int verifyFileCount = RecoverCountFromFollowersFile(fullPath);
                CPH.LogInfo($"[SUB MASS] Updated={currentCount} | +{addAmount} | VerifyFile={verifyFileCount} | Gifter={gifter} | Display={displayUser} | ID={uniqueId}");
            }
            catch (Exception ex)
            {
                CPH.LogWarn("[SUB MASS] Error updating data_followers.js: " + ex.Message);
            }
            finally
            {
                if (lockTaken)
                {
                    try { mutex.ReleaseMutex(); } catch { }
                }
            }
        }

        return true;
    }
}
